#!/usr/bin/env python3

import os
import re
import argparse
import datetime
import subprocess

class STConflictFile:

    UID = r'(?P<uid>[0-9A-Z]{7})'
    DATE = r'(?P<dy>[0-9]{4})(?P<dm>[0-9]{2})(?P<dd>[0-9]{2})'
    TIME = r'(?P<th>[0-9]{2})(?P<tm>[0-9]{2})(?P<ts>[0-9]{2})'

    def __init__(self, path, base, name, conflicts):
        self.path = path
        self.base = base
        self.name = name
        self.conflicts = conflicts

        #
        # selected: the current selected-visible version of the file
        # original: the original file this version was based on
        #
        # keep in mind conflicts may be recursive, so it is
        # possible (and likely) that selected == original
        #
        self.selected, self.ext = os.path.splitext(STConflict.REGEX.sub('', name))
        self.original = self.format(conflicts = self.conflicts[:-1], ext = '')
        self.root = self.original == self.selected

        # sanity check
        assert(self.name == str(self))

        self.parent = None
        self.children = []

    def __repr__(self):
        return self.format()

    def format(self, name = None, conflicts = None, ext = None):
        if conflicts is None: conflicts = self.conflicts
        if ext is None: ext = self.ext
        if name is None: name = self.selected
        return '{}{}{}'.format(name, STConflict.format(conflicts), ext)

    def set_parent(self, parent):
        assert(not self.parent)
        self.parent = parent

        assert(not self in parent.children)
        parent.children.append(self)

    def age_in_seconds(self):
        return Timestamp.file_age(self)

    def top(self):
        return self.conflicts[-1]

    def order(self):
        return self.top().order()

    def canonical_name(self):
        return os.path.join(os.path.realpath(self.base), self.name)

    def canonical_selected(self):
        return os.path.join(os.path.realpath(self.base), self.format(name = self.selected, conflicts = []))

    def canonical_original(self):
        return os.path.join(os.path.realpath(self.base), self.format(name = self.original, conflicts = []))

    def canonical_backup(self, args):
        return os.path.join(self.backup_directory(), self.name)

    def backup_directory(self, args):
        return os.path.join(f.path, args.backup_dir)

    def timestamp(self):
        return self.top().timestamp

    def delete(self, args, commit = False):
        if args.commit:
            os.remove(self.canonical_name())
        else:
            print('delete: {}'.format(self.name))

    def backup(self, args, commit = False):
        if args.commit:
            if not os.path.isdir(self.backup_directory()):
                os.mkdir(self.backup_directory())
            os.rename(self.canonical_name(), self.canonical_backup(args))
        else:
            print('backup: {}'.format(self.name))

    def show_file(path, args):

        try:
            with open(path, 'r') as fd:
                txt = fd.read()
                print(txt[:-1])
        except:
            print('error: failed to show file: {}'.format(path))

    def show_diff(a, b, args):

        command = ['diff', '--side-by-side', a, b]
        try:
            print('>>> running {}'.format(command))
            process, (out, err) = STConflictFile.shell(command)
            if process.returncode in [0, 1]:
                txt = out.decode('utf-8')
                print('<<< stdout')
                print(txt[:-1])
                print('>>>')
            else:
                txt = err.decode('utf-8')
                print('<<< stderr')
                print(txt[:-1])
                print('>>>')
        except:
            print('error: failed to run command: {}'.format(command))

    def shell(command):
        process = subprocess.Popen(command, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
        return process, process.communicate()

    def prompt(self, args):

        quit = False
        while not quit:

            c = self.canonical_name()
            o = self.canonical_original()
            b = self.canonical_selected()

            tc = self.timestamp().format()
            to = ' ROOT ' if self.root else self.parent.timestamp().format()

            print('')
            print('--- PROMPT ---')
            print('[{}] {}'.format(tc, self.name))
            print('[{}] {}'.format(to, '{}{}'.format(self.original, self.ext)))
            print('---')
            print('sc: show conflict file')
            print('so: show original file')
            print('sb: show base file')
            print('kc: keep conflict file')
            print('ko: keep original file')
            print('kb: keep base file')
            print('do: diff conflict/original')
            print('db: diff conflict/base')
            print('qq: quit')
            print('---')

            i = input('>>> ')
            i = i[:2]

            if   i == 'sc': STConflictFile.show_file(c, args)
            elif i == 'so': STConflictFile.show_file(o, args)
            elif i == 'sb': STConflictFile.show_file(b, args)
            elif i == 'kc': STConflictFile.show_file(c, args)
            elif i == 'ko': STConflictFile.show_file(o, args)
            elif i == 'kb': STConflictFile.show_file(b, args)
            elif i == 'do': STConflictFile.show_diff(o, c, args)
            elif i == 'db': STConflictFile.show_diff(b, c, args)
            elif i == 'qq': quit = True

class Date:

    def __init__(self, yy, mm, dd):
        self.yy = int(yy)
        self.mm = int(mm)
        self.dd = int(dd)

    def __repr__(self):
        """Same as syncthings date representation"""
        return '{:>04}{:>02}{:>02}'.format(self.yy, self.mm, self.dd)

    def order(self):
        return self.yy * 356* + self.mm * 30 + self.dd

class Time:

    def __init__(self, hh, mm, ss):
        self.hh = int(hh)
        self.mm = int(mm)
        self.ss = int(ss)

    def __repr__(self):
        """Same as syncthings time representation"""
        return '{:>02}{:>02}{:>02}'.format(self.hh, self.mm, self.ss)

    def order(self):
        return self.hh * 60*60 + self.mm * 60 + self.ss

class Timestamp:

    NOW = None

    def __init__(self, date, time):
        self.date = date
        self.time = time
        self.dt = datetime.datetime(date.yy, date.mm, date.dd, time.hh, time.mm, time.ss)

    def __repr__(self):
        return '{}{}'.format(self.date, self.time)

    def from_dt(dt):
        date = Date(dt.year, dt.month, dt.day)
        time = Time(dt.hour, dt.minute, dt.second)
        return Timestamp(date, time)

    def now():
        if not Timestamp.NOW:
            Timestamp.NOW = Timestamp.from_dt(datetime.datetime.now())
        return Timestamp.NOW

    def file_age(f):
        return Timestamp.delta(Timestamp.now(), f.top().timestamp)

    def order(self):
        return int(str(self))

    def delta(self, ts):
        return (self.dt - ts.dt).total_seconds()

    def format(self):
        return self.dt.strftime('%b %d')

class STConflict:

    REGEX = re.compile(r'\.sync-conflict-({})-({})-({})'.format(STConflictFile.DATE, STConflictFile.TIME, STConflictFile.UID))

    def __init__(self, date, time, uid):
        self.date = Date(*date)
        self.time = Time(*time)
        self.uid = uid
        self.timestamp = Timestamp(self.date, self.time)

    def __repr__(self):
        """Same as syncthings represention of the conflict"""
        return '.sync-conflict-{}-{}-{}'.format(self.date, self.time, self.uid)

    def order(self):
        """Order conflicts chronologically"""
        return self.timestamp.order()

    def format(conflicts):
        """Helper function to format a list of conflicts"""
        s = ''
        for c in conflicts:
            s = '{}{}'.format(s, c)
        return s

    def parse(path):
        """Extract conflict data from file name"""
        conflicts = []
        for c in STConflict.REGEX.finditer(path):
            date = (c.group('dy'), c.group('dm'), c.group('dd'))
            time = (c.group('th'), c.group('tm'), c.group('ts'))
            uid = c.group('uid')
            conflicts.append(STConflict(date, time, uid))
        return conflicts

class Heuristic:

    NONE     = 0
    OLD      = 1
    SAME     = 2
    NESTED   = 3
    ORPHANED = 4
    OBSOLETE = 5
    YOUNG    = 6

    def is_old(f, args):
        """Check if a conflict is considered stale"""
        days_threshold = 30
        return f.age_in_seconds() > days_threshold * 60*60*24

    def is_young(f, args):
        """Check if a conflict is considered fresh"""
        days_threshold = 5
        return f.age_in_seconds() < days_threshold * 60*60*24

    def is_same(f, args):
        """Check if a conflict exactly matches the original (shouldn't happen but can't hurt)"""
        # TODO: implement this (just use diff?)
        return False

    def is_nested(f, args):
        """Check if a conflict is based on another conflict"""
        return f.parent is not None

    def is_orphan(f, args):
        """Check if a conflict's original file has vanished"""
        return not os.path.isfile(f.canonical_original())

    def is_obsolete(f, args):
        """Check if a conflict's base file has vanished"""
        return not os.path.isfile(f.canonical_selected())

    def check(f, args):
        """Check heuristics one-by-one"""
        mapping = {
            Heuristic.OLD:      Heuristic.is_old,
            Heuristic.OBSOLETE: Heuristic.is_obsolete,
            Heuristic.SAME:     Heuristic.is_same,
            Heuristic.ORPHANED: Heuristic.is_orphan,
            Heuristic.NESTED:   Heuristic.is_nested,
            Heuristic.YOUNG:    Heuristic.is_young,
        }
        for i, heuristic in mapping.items():
            if heuristic(f, args):
                return i
        return Heuristic.NONE

class Action:

    DELETE = 0
    BACKUP = 1
    PROMPT = 2

    NAMES = {
        DELETE: "DELETE",
        BACKUP: "BACKUP",
        PROMPT: "PROMPT",
    }

    def delete(f, args): f.delete(args)
    def backup(f, args): f.backup(args)
    def prompt(f, args): f.prompt(args)

    def mapping(heuristic):
        mapping = {
            Heuristic.OLD:      Action.DELETE,
            Heuristic.SAME:     Action.DELETE,
            Heuristic.NESTED:   Action.DELETE,
            Heuristic.OBSOLETE: Action.DELETE,
            Heuristic.ORPHANED: Action.DELETE,
            Heuristic.YOUNG:    Action.PROMPT,
            Heuristic.NONE:     Action.BACKUP,
        }
        return mapping[heuristic]

    def run(f, action, args):
        """Run the action mapped to the heuristics result"""
        call = ACTION_MAP[action]
        call(f, args)

ACTION_MAP = {
    Action.DELETE: Action.delete,
    Action.BACKUP: Action.backup,
    Action.PROMPT: Action.prompt,
}

class Cli:

    def __init__(self, args):
        self.args = args

    def scan(self):
        """Scan all provided paths for conflicts"""
        scan = []
        for path in self.args.PATH:
            assert(os.path.isdir(os.path.join(path, '.stfolder')))
            for base, directories, files in os.walk(path):

                if args.backup_dir in directories:
                    directories.remove(args.backup_dir)

                for name in files:
                    conflicts = STConflict.parse(name)
                    if conflicts:
                        scan.append(STConflictFile(path, base, name, conflicts))
        return scan

    def conflict_map(self, scan):
        """Map path name -> file conflict object"""
        conflict_map = {}
        for f in scan:
            conflict_map[f.canonical_name()] = f
        return conflict_map

    def conflict_tree(self, conflict_map):
        """Graph conflicts into tree structure"""
        conflict_tree = []
        for k, f in conflict_map.items():
            if f.root:
                assert(not f in conflict_tree)
                conflict_tree.append(f)
            else:
                o = conflict_map[f.canonical_original()]
                f.set_parent(o)
        return conflict_tree

    def actions(self, conflict_map):
        """Generate list of actions for the given conflicts"""
        actions = [[], [], []]
        for k, f in conflict_map.items():
            a = Action.mapping(Heuristic.check(f, self.args))
            actions[a].append(f)
        return actions

    def report(self, actions):
        """Generate a report of actions to take"""
        ORDER = [Action.DELETE, Action.BACKUP, Action.PROMPT]
        for i, a in enumerate(ORDER):
            if i > 0: print('')

            print('[{}] {} files total'.format(Action.NAMES[a], len(actions[a])))
            for f in actions[a]:
                print(f)

    def run(self):
        """Main routine and entry point"""

        # The process is simple:
        #   1. Scan for conflicts
        #   2. Apply heuristics
        #   3. Run the associated actions

        conflict_map = self.conflict_map(self.scan())
        conflict_tree = self.conflict_tree(conflict_map)

        actions = self.actions(conflict_map)
        self.report(actions)

        for f in actions[Action.PROMPT]:
            f.prompt(self.args)

description = 'syncthing conflict resolver'
version = '0.1'
parser = argparse.ArgumentParser(description = description)

parser.add_argument('--version', action = 'version', version = version, help = 'print version and exit')
parser.add_argument('--backup-dir', type = str, help = 'location to back up to', default = '.stbackups')
parser.add_argument('--version-dir', type = str, help = 'location to back up to', default = '.stversions')
parser.add_argument('--commit', action = 'store_true', help = 'actually run commands')
parser.add_argument('PATH', type = str, help = 'path specification', nargs = '*')

args = parser.parse_args()
cli = Cli(args)
cli.run()
